//
// Generated file, do not edit! Created by opp_msgc 4.2 from UCACPacket.msg.
//

#ifndef _UCACPACKET_M_H_
#define _UCACPACKET_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0402
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "pbc/pbc.h"
	#include "grs.h"
    typedef struct{
        element_t D;
        element_t Di[NUM_SHARE];
        element_t Di_prime[NUM_SHARE];
    }Token;
// }}



/**
 * Enum generated from <tt>UCACPacket.msg</tt> by opp_msgc.
 * <pre>
 * enum UCACPacketType
 * {
 *     
 *     CONN_REQ = 0;
 *     CONN_ACK = 1;
 *     
 *     DISC_REQ = 2;
 *     DISC_ACK = 3;
 *     
 *     REDIRECT = 4;
 * 	
 *     CONFINED_D_REQ = 5;	
 * 	CONFINED_D_RES = 6;	
 * 	
 *     D_REQ = 7;
 *     
 *     D_RES = 8;
 *     
 *     PRNT_REQ = 9;
 *     PRNT_RES = 10;
 *     
 *     FILE_REQ = 11;
 *     FILE_RES = 12;
 *     
 *     AUTZ_REQ = 13;
 *     AUTZ_RES = 14;
 *     
 *     AUTN_REQ = 15;
 *     AUTN_RES = 16;
 *     
 *     ATTR_REQ = 17;
 *     ATTR_RES = 18;
 *     
 *     DES1_REQ = 19;
 *     DES1_RES = 20;
 *     
 *     DES2_REQ = 21;
 *     DES2_RES = 22;
 *     
 *     INI_REQ = 23;
 *     INI_RES = 24;
 *     
 *     TOKEN = 25;
 *     DES1_RES_FAILED = 26;   
 * };
 * </pre>
 */
enum UCACPacketType {
    CONN_REQ = 0,
    CONN_ACK = 1,
    DISC_REQ = 2,
    DISC_ACK = 3,
    REDIRECT = 4,
    CONFINED_D_REQ = 5,
    CONFINED_D_RES = 6,
    D_REQ = 7,
    D_RES = 8,
    PRNT_REQ = 9,
    PRNT_RES = 10,
    FILE_REQ = 11,
    FILE_RES = 12,
    AUTZ_REQ = 13,
    AUTZ_RES = 14,
    AUTN_REQ = 15,
    AUTN_RES = 16,
    ATTR_REQ = 17,
    ATTR_RES = 18,
    DES1_REQ = 19,
    DES1_RES = 20,
    DES2_REQ = 21,
    DES2_RES = 22,
    INI_REQ = 23,
    INI_RES = 24,
    TOKEN = 25,
    DES1_RES_FAILED = 26
};

/**
 * Class generated from <tt>UCACPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet UCACPacket
 * {
 *     int srcAddress;
 *     int destAddress;
 *     int srcProcId;
 *     int destProcId;
 * };
 * </pre>
 */
class UCACPacket : public ::cPacket
{
  protected:
    int srcAddress_var;
    int destAddress_var;
    int srcProcId_var;
    int destProcId_var;

  private:
    void copy(const UCACPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UCACPacket&);

  public:
    UCACPacket(const char *name=NULL, int kind=0);
    UCACPacket(const UCACPacket& other);
    virtual ~UCACPacket();
    UCACPacket& operator=(const UCACPacket& other);
    virtual UCACPacket *dup() const {return new UCACPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    virtual int getDestAddress() const;
    virtual void setDestAddress(int destAddress);
    virtual int getSrcProcId() const;
    virtual void setSrcProcId(int srcProcId);
    virtual int getDestProcId() const;
    virtual void setDestProcId(int destProcId);
};

inline void doPacking(cCommBuffer *b, UCACPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UCACPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>UCACPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet UCACAttrPacket extends UCACPacket
 * {
 *     string attr[NUM_SHARE];
 * };
 * </pre>
 */
class UCACAttrPacket : public ::UCACPacket
{
  protected:
    opp_string attr_var[NUM_SHARE];

  private:
    void copy(const UCACAttrPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UCACAttrPacket&);

  public:
    UCACAttrPacket(const char *name=NULL, int kind=0);
    UCACAttrPacket(const UCACAttrPacket& other);
    virtual ~UCACAttrPacket();
    UCACAttrPacket& operator=(const UCACAttrPacket& other);
    virtual UCACAttrPacket *dup() const {return new UCACAttrPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getAttrArraySize() const;
    virtual const char * getAttr(unsigned int k) const;
    virtual void setAttr(unsigned int k, const char * attr);
};

inline void doPacking(cCommBuffer *b, UCACAttrPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UCACAttrPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>UCACPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet UCACRedirectPacket extends UCACPacket
 * {
 *     string ID;
 *     string Redirect_URI;
 *     string access_policy;
 * }
 * </pre>
 */
class UCACRedirectPacket : public ::UCACPacket
{
  protected:
    opp_string ID_var;
    opp_string Redirect_URI_var;
    opp_string access_policy_var;

  private:
    void copy(const UCACRedirectPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UCACRedirectPacket&);

  public:
    UCACRedirectPacket(const char *name=NULL, int kind=0);
    UCACRedirectPacket(const UCACRedirectPacket& other);
    virtual ~UCACRedirectPacket();
    UCACRedirectPacket& operator=(const UCACRedirectPacket& other);
    virtual UCACRedirectPacket *dup() const {return new UCACRedirectPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getID() const;
    virtual void setID(const char * ID);
    virtual const char * getRedirect_URI() const;
    virtual void setRedirect_URI(const char * Redirect_URI);
    virtual const char * getAccess_policy() const;
    virtual void setAccess_policy(const char * access_policy);
};

inline void doPacking(cCommBuffer *b, UCACRedirectPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UCACRedirectPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>UCACPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet UCACRedirectDesPacket extends UCACPacket
 * {
 *  	string ID;
 *  	string Redirect_URI;
 *  	element_s nounce;
 * }
 * </pre>
 */
class UCACRedirectDesPacket : public ::UCACPacket
{
  protected:
    opp_string ID_var;
    opp_string Redirect_URI_var;
    element_s nounce_var;

  private:
    void copy(const UCACRedirectDesPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UCACRedirectDesPacket&);

  public:
    UCACRedirectDesPacket(const char *name=NULL, int kind=0);
    UCACRedirectDesPacket(const UCACRedirectDesPacket& other);
    virtual ~UCACRedirectDesPacket();
    UCACRedirectDesPacket& operator=(const UCACRedirectDesPacket& other);
    virtual UCACRedirectDesPacket *dup() const {return new UCACRedirectDesPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getID() const;
    virtual void setID(const char * ID);
    virtual const char * getRedirect_URI() const;
    virtual void setRedirect_URI(const char * Redirect_URI);
    virtual element_s& getNounce();
    virtual const element_s& getNounce() const {return const_cast<UCACRedirectDesPacket*>(this)->getNounce();}
    virtual void setNounce(const element_s& nounce);
};

inline void doPacking(cCommBuffer *b, UCACRedirectDesPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UCACRedirectDesPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>UCACPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet UCACAuthenticatePacket extends UCACPacket
 * {
 *     string ID;
 *     string credential;
 * };
 * </pre>
 */
class UCACAuthenticatePacket : public ::UCACPacket
{
  protected:
    opp_string ID_var;
    opp_string credential_var;

  private:
    void copy(const UCACAuthenticatePacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UCACAuthenticatePacket&);

  public:
    UCACAuthenticatePacket(const char *name=NULL, int kind=0);
    UCACAuthenticatePacket(const UCACAuthenticatePacket& other);
    virtual ~UCACAuthenticatePacket();
    UCACAuthenticatePacket& operator=(const UCACAuthenticatePacket& other);
    virtual UCACAuthenticatePacket *dup() const {return new UCACAuthenticatePacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getID() const;
    virtual void setID(const char * ID);
    virtual const char * getCredential() const;
    virtual void setCredential(const char * credential);
};

inline void doPacking(cCommBuffer *b, UCACAuthenticatePacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UCACAuthenticatePacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>UCACPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet UCACTokenPacket extends UCACPacket
 * {
 *     Token sk_token;
 *     element_s nounce;
 *     int procId;
 * };
 * </pre>
 */
class UCACTokenPacket : public ::UCACPacket
{
  protected:
    Token sk_token_var;
    element_s nounce_var;
    int procId_var;

  private:
    void copy(const UCACTokenPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UCACTokenPacket&);

  public:
    UCACTokenPacket(const char *name=NULL, int kind=0);
    UCACTokenPacket(const UCACTokenPacket& other);
    virtual ~UCACTokenPacket();
    UCACTokenPacket& operator=(const UCACTokenPacket& other);
    virtual UCACTokenPacket *dup() const {return new UCACTokenPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual Token& getSk_token();
    virtual const Token& getSk_token() const {return const_cast<UCACTokenPacket*>(this)->getSk_token();}
    virtual void setSk_token(const Token& sk_token);
    virtual element_s& getNounce();
    virtual const element_s& getNounce() const {return const_cast<UCACTokenPacket*>(this)->getNounce();}
    virtual void setNounce(const element_s& nounce);
    virtual int getProcId() const;
    virtual void setProcId(int procId);
};

inline void doPacking(cCommBuffer *b, UCACTokenPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UCACTokenPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>UCACPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet UCACDataPacket extends UCACPacket
 * {
 *     string Payload;
 * };
 * </pre>
 */
class UCACDataPacket : public ::UCACPacket
{
  protected:
    opp_string Payload_var;

  private:
    void copy(const UCACDataPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UCACDataPacket&);

  public:
    UCACDataPacket(const char *name=NULL, int kind=0);
    UCACDataPacket(const UCACDataPacket& other);
    virtual ~UCACDataPacket();
    UCACDataPacket& operator=(const UCACDataPacket& other);
    virtual UCACDataPacket *dup() const {return new UCACDataPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual const char * getPayload() const;
    virtual void setPayload(const char * Payload);
};

inline void doPacking(cCommBuffer *b, UCACDataPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UCACDataPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>UCACPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet UCACInitializePacket extends UCACPacket
 * {
 *     
 *     pairing_s pairing;
 *     element_s g;
 *     element_s h;
 *     element_s f;
 *     
 *     element_s beta;
 *     
 *     element_s owner_sk;
 *     
 *     element_s owner_pub;  
 * }
 * </pre>
 */
class UCACInitializePacket : public ::UCACPacket
{
  protected:
    pairing_s pairing_var;
    element_s g_var;
    element_s h_var;
    element_s f_var;
    element_s beta_var;
    element_s owner_sk_var;
    element_s owner_pub_var;

  private:
    void copy(const UCACInitializePacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UCACInitializePacket&);

  public:
    UCACInitializePacket(const char *name=NULL, int kind=0);
    UCACInitializePacket(const UCACInitializePacket& other);
    virtual ~UCACInitializePacket();
    UCACInitializePacket& operator=(const UCACInitializePacket& other);
    virtual UCACInitializePacket *dup() const {return new UCACInitializePacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual pairing_s& getPairing();
    virtual const pairing_s& getPairing() const {return const_cast<UCACInitializePacket*>(this)->getPairing();}
    virtual void setPairing(const pairing_s& pairing);
    virtual element_s& getG();
    virtual const element_s& getG() const {return const_cast<UCACInitializePacket*>(this)->getG();}
    virtual void setG(const element_s& g);
    virtual element_s& getH();
    virtual const element_s& getH() const {return const_cast<UCACInitializePacket*>(this)->getH();}
    virtual void setH(const element_s& h);
    virtual element_s& getF();
    virtual const element_s& getF() const {return const_cast<UCACInitializePacket*>(this)->getF();}
    virtual void setF(const element_s& f);
    virtual element_s& getBeta();
    virtual const element_s& getBeta() const {return const_cast<UCACInitializePacket*>(this)->getBeta();}
    virtual void setBeta(const element_s& beta);
    virtual element_s& getOwner_sk();
    virtual const element_s& getOwner_sk() const {return const_cast<UCACInitializePacket*>(this)->getOwner_sk();}
    virtual void setOwner_sk(const element_s& owner_sk);
    virtual element_s& getOwner_pub();
    virtual const element_s& getOwner_pub() const {return const_cast<UCACInitializePacket*>(this)->getOwner_pub();}
    virtual void setOwner_pub(const element_s& owner_pub);
};

inline void doPacking(cCommBuffer *b, UCACInitializePacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, UCACInitializePacket& obj) {obj.parsimUnpack(b);}


#endif // _UCACPACKET_M_H_
